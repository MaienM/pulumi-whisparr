// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * <!-- subcategory:Media Management -->Media Management resource.
 * For more information refer to [Naming](https://wiki.servarr.com/whisparr/settings#file-management) documentation.
 *
 * ## Import
 *
 * import does not need parameters
 *
 * ```sh
 *  $ pulumi import whisparr:MediaManagement/mediaManagement:MediaManagement example
 * ```
 */
export class MediaManagement extends pulumi.CustomResource {
    /**
     * Get an existing MediaManagement resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: MediaManagementState, opts?: pulumi.CustomResourceOptions): MediaManagement {
        return new MediaManagement(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'whisparr:MediaManagement/mediaManagement:MediaManagement';

    /**
     * Returns true if the given object is an instance of MediaManagement.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is MediaManagement {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === MediaManagement.__pulumiType;
    }

    /**
     * Auto rename folders.
     */
    public readonly autoRenameFolders!: pulumi.Output<boolean>;
    /**
     * Auto unmonitor previously downloaded movies.
     */
    public readonly autoUnmonitorPreviouslyDownloadedMovies!: pulumi.Output<boolean>;
    /**
     * Permission in linux format.
     */
    public readonly chmodFolder!: pulumi.Output<string>;
    /**
     * Group used for permission.
     */
    public readonly chownGroup!: pulumi.Output<string>;
    /**
     * Use hardlinks instead of copy.
     */
    public readonly copyUsingHardlinks!: pulumi.Output<boolean>;
    /**
     * Create empty movies directories.
     */
    public readonly createEmptyMovieFolders!: pulumi.Output<boolean>;
    /**
     * Delete empty movies directories.
     */
    public readonly deleteEmptyFolders!: pulumi.Output<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    public readonly downloadPropersAndRepacks!: pulumi.Output<string>;
    /**
     * Scan files details.
     */
    public readonly enableMediaInfo!: pulumi.Output<boolean>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    public readonly extraFileExtensions!: pulumi.Output<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'cinemas, and 'release'.
     */
    public readonly fileDate!: pulumi.Output<string>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    public readonly importExtraFiles!: pulumi.Output<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    public readonly minimumFreeSpaceWhenImporting!: pulumi.Output<number>;
    /**
     * Path default static.
     */
    public readonly pathsDefaultStatic!: pulumi.Output<boolean>;
    /**
     * Recycle bin absolute path.
     */
    public readonly recycleBin!: pulumi.Output<string>;
    /**
     * Recyle bin days of retention.
     */
    public readonly recycleBinCleanupDays!: pulumi.Output<number>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    public readonly rescanAfterRefresh!: pulumi.Output<string>;
    /**
     * Set permission for imported files.
     */
    public readonly setPermissionsLinux!: pulumi.Output<boolean>;
    /**
     * Skip free space check before importing.
     */
    public readonly skipFreeSpaceCheckWhenImporting!: pulumi.Output<boolean>;

    /**
     * Create a MediaManagement resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: MediaManagementArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: MediaManagementArgs | MediaManagementState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as MediaManagementState | undefined;
            resourceInputs["autoRenameFolders"] = state ? state.autoRenameFolders : undefined;
            resourceInputs["autoUnmonitorPreviouslyDownloadedMovies"] = state ? state.autoUnmonitorPreviouslyDownloadedMovies : undefined;
            resourceInputs["chmodFolder"] = state ? state.chmodFolder : undefined;
            resourceInputs["chownGroup"] = state ? state.chownGroup : undefined;
            resourceInputs["copyUsingHardlinks"] = state ? state.copyUsingHardlinks : undefined;
            resourceInputs["createEmptyMovieFolders"] = state ? state.createEmptyMovieFolders : undefined;
            resourceInputs["deleteEmptyFolders"] = state ? state.deleteEmptyFolders : undefined;
            resourceInputs["downloadPropersAndRepacks"] = state ? state.downloadPropersAndRepacks : undefined;
            resourceInputs["enableMediaInfo"] = state ? state.enableMediaInfo : undefined;
            resourceInputs["extraFileExtensions"] = state ? state.extraFileExtensions : undefined;
            resourceInputs["fileDate"] = state ? state.fileDate : undefined;
            resourceInputs["importExtraFiles"] = state ? state.importExtraFiles : undefined;
            resourceInputs["minimumFreeSpaceWhenImporting"] = state ? state.minimumFreeSpaceWhenImporting : undefined;
            resourceInputs["pathsDefaultStatic"] = state ? state.pathsDefaultStatic : undefined;
            resourceInputs["recycleBin"] = state ? state.recycleBin : undefined;
            resourceInputs["recycleBinCleanupDays"] = state ? state.recycleBinCleanupDays : undefined;
            resourceInputs["rescanAfterRefresh"] = state ? state.rescanAfterRefresh : undefined;
            resourceInputs["setPermissionsLinux"] = state ? state.setPermissionsLinux : undefined;
            resourceInputs["skipFreeSpaceCheckWhenImporting"] = state ? state.skipFreeSpaceCheckWhenImporting : undefined;
        } else {
            const args = argsOrState as MediaManagementArgs | undefined;
            if ((!args || args.autoRenameFolders === undefined) && !opts.urn) {
                throw new Error("Missing required property 'autoRenameFolders'");
            }
            if ((!args || args.autoUnmonitorPreviouslyDownloadedMovies === undefined) && !opts.urn) {
                throw new Error("Missing required property 'autoUnmonitorPreviouslyDownloadedMovies'");
            }
            if ((!args || args.chmodFolder === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chmodFolder'");
            }
            if ((!args || args.chownGroup === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chownGroup'");
            }
            if ((!args || args.copyUsingHardlinks === undefined) && !opts.urn) {
                throw new Error("Missing required property 'copyUsingHardlinks'");
            }
            if ((!args || args.createEmptyMovieFolders === undefined) && !opts.urn) {
                throw new Error("Missing required property 'createEmptyMovieFolders'");
            }
            if ((!args || args.deleteEmptyFolders === undefined) && !opts.urn) {
                throw new Error("Missing required property 'deleteEmptyFolders'");
            }
            if ((!args || args.downloadPropersAndRepacks === undefined) && !opts.urn) {
                throw new Error("Missing required property 'downloadPropersAndRepacks'");
            }
            if ((!args || args.enableMediaInfo === undefined) && !opts.urn) {
                throw new Error("Missing required property 'enableMediaInfo'");
            }
            if ((!args || args.extraFileExtensions === undefined) && !opts.urn) {
                throw new Error("Missing required property 'extraFileExtensions'");
            }
            if ((!args || args.fileDate === undefined) && !opts.urn) {
                throw new Error("Missing required property 'fileDate'");
            }
            if ((!args || args.importExtraFiles === undefined) && !opts.urn) {
                throw new Error("Missing required property 'importExtraFiles'");
            }
            if ((!args || args.minimumFreeSpaceWhenImporting === undefined) && !opts.urn) {
                throw new Error("Missing required property 'minimumFreeSpaceWhenImporting'");
            }
            if ((!args || args.pathsDefaultStatic === undefined) && !opts.urn) {
                throw new Error("Missing required property 'pathsDefaultStatic'");
            }
            if ((!args || args.recycleBin === undefined) && !opts.urn) {
                throw new Error("Missing required property 'recycleBin'");
            }
            if ((!args || args.recycleBinCleanupDays === undefined) && !opts.urn) {
                throw new Error("Missing required property 'recycleBinCleanupDays'");
            }
            if ((!args || args.rescanAfterRefresh === undefined) && !opts.urn) {
                throw new Error("Missing required property 'rescanAfterRefresh'");
            }
            if ((!args || args.setPermissionsLinux === undefined) && !opts.urn) {
                throw new Error("Missing required property 'setPermissionsLinux'");
            }
            if ((!args || args.skipFreeSpaceCheckWhenImporting === undefined) && !opts.urn) {
                throw new Error("Missing required property 'skipFreeSpaceCheckWhenImporting'");
            }
            resourceInputs["autoRenameFolders"] = args ? args.autoRenameFolders : undefined;
            resourceInputs["autoUnmonitorPreviouslyDownloadedMovies"] = args ? args.autoUnmonitorPreviouslyDownloadedMovies : undefined;
            resourceInputs["chmodFolder"] = args ? args.chmodFolder : undefined;
            resourceInputs["chownGroup"] = args ? args.chownGroup : undefined;
            resourceInputs["copyUsingHardlinks"] = args ? args.copyUsingHardlinks : undefined;
            resourceInputs["createEmptyMovieFolders"] = args ? args.createEmptyMovieFolders : undefined;
            resourceInputs["deleteEmptyFolders"] = args ? args.deleteEmptyFolders : undefined;
            resourceInputs["downloadPropersAndRepacks"] = args ? args.downloadPropersAndRepacks : undefined;
            resourceInputs["enableMediaInfo"] = args ? args.enableMediaInfo : undefined;
            resourceInputs["extraFileExtensions"] = args ? args.extraFileExtensions : undefined;
            resourceInputs["fileDate"] = args ? args.fileDate : undefined;
            resourceInputs["importExtraFiles"] = args ? args.importExtraFiles : undefined;
            resourceInputs["minimumFreeSpaceWhenImporting"] = args ? args.minimumFreeSpaceWhenImporting : undefined;
            resourceInputs["pathsDefaultStatic"] = args ? args.pathsDefaultStatic : undefined;
            resourceInputs["recycleBin"] = args ? args.recycleBin : undefined;
            resourceInputs["recycleBinCleanupDays"] = args ? args.recycleBinCleanupDays : undefined;
            resourceInputs["rescanAfterRefresh"] = args ? args.rescanAfterRefresh : undefined;
            resourceInputs["setPermissionsLinux"] = args ? args.setPermissionsLinux : undefined;
            resourceInputs["skipFreeSpaceCheckWhenImporting"] = args ? args.skipFreeSpaceCheckWhenImporting : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(MediaManagement.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering MediaManagement resources.
 */
export interface MediaManagementState {
    /**
     * Auto rename folders.
     */
    autoRenameFolders?: pulumi.Input<boolean>;
    /**
     * Auto unmonitor previously downloaded movies.
     */
    autoUnmonitorPreviouslyDownloadedMovies?: pulumi.Input<boolean>;
    /**
     * Permission in linux format.
     */
    chmodFolder?: pulumi.Input<string>;
    /**
     * Group used for permission.
     */
    chownGroup?: pulumi.Input<string>;
    /**
     * Use hardlinks instead of copy.
     */
    copyUsingHardlinks?: pulumi.Input<boolean>;
    /**
     * Create empty movies directories.
     */
    createEmptyMovieFolders?: pulumi.Input<boolean>;
    /**
     * Delete empty movies directories.
     */
    deleteEmptyFolders?: pulumi.Input<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    downloadPropersAndRepacks?: pulumi.Input<string>;
    /**
     * Scan files details.
     */
    enableMediaInfo?: pulumi.Input<boolean>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    extraFileExtensions?: pulumi.Input<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'cinemas, and 'release'.
     */
    fileDate?: pulumi.Input<string>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    importExtraFiles?: pulumi.Input<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    minimumFreeSpaceWhenImporting?: pulumi.Input<number>;
    /**
     * Path default static.
     */
    pathsDefaultStatic?: pulumi.Input<boolean>;
    /**
     * Recycle bin absolute path.
     */
    recycleBin?: pulumi.Input<string>;
    /**
     * Recyle bin days of retention.
     */
    recycleBinCleanupDays?: pulumi.Input<number>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    rescanAfterRefresh?: pulumi.Input<string>;
    /**
     * Set permission for imported files.
     */
    setPermissionsLinux?: pulumi.Input<boolean>;
    /**
     * Skip free space check before importing.
     */
    skipFreeSpaceCheckWhenImporting?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a MediaManagement resource.
 */
export interface MediaManagementArgs {
    /**
     * Auto rename folders.
     */
    autoRenameFolders: pulumi.Input<boolean>;
    /**
     * Auto unmonitor previously downloaded movies.
     */
    autoUnmonitorPreviouslyDownloadedMovies: pulumi.Input<boolean>;
    /**
     * Permission in linux format.
     */
    chmodFolder: pulumi.Input<string>;
    /**
     * Group used for permission.
     */
    chownGroup: pulumi.Input<string>;
    /**
     * Use hardlinks instead of copy.
     */
    copyUsingHardlinks: pulumi.Input<boolean>;
    /**
     * Create empty movies directories.
     */
    createEmptyMovieFolders: pulumi.Input<boolean>;
    /**
     * Delete empty movies directories.
     */
    deleteEmptyFolders: pulumi.Input<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    downloadPropersAndRepacks: pulumi.Input<string>;
    /**
     * Scan files details.
     */
    enableMediaInfo: pulumi.Input<boolean>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    extraFileExtensions: pulumi.Input<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'cinemas, and 'release'.
     */
    fileDate: pulumi.Input<string>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    importExtraFiles: pulumi.Input<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    minimumFreeSpaceWhenImporting: pulumi.Input<number>;
    /**
     * Path default static.
     */
    pathsDefaultStatic: pulumi.Input<boolean>;
    /**
     * Recycle bin absolute path.
     */
    recycleBin: pulumi.Input<string>;
    /**
     * Recyle bin days of retention.
     */
    recycleBinCleanupDays: pulumi.Input<number>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    rescanAfterRefresh: pulumi.Input<string>;
    /**
     * Set permission for imported files.
     */
    setPermissionsLinux: pulumi.Input<boolean>;
    /**
     * Skip free space check before importing.
     */
    skipFreeSpaceCheckWhenImporting: pulumi.Input<boolean>;
}
